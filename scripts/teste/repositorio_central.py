#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
REPOSIT√ìRIO CENTRAL - VALIDADOR E SINCRONIZADOR DE DADOS
Mant√©m a integridade entre Dashboard, Excel e Relat√≥rios
"""

import pandas as pd
import json
import os
import re
from datetime import datetime
import shutil


class RepositorioCentral:
    """Classe para gerenciar reposit√≥rios centralizados do sistema"""

    def __init__(self):
        # Arquivos principais (fonte √∫nica da verdade)
        self.arquivo_principal = (
            "distancias_escolas_diretorias_completo_63_corrigido.xlsx"
        )
        self.arquivo_veiculos = "dados_veiculos_diretorias.json"
        self.arquivo_dashboard = "dashboard_integrado.html"

        # Arquivos de relat√≥rios (gerados)
        self.relatorio_excel = "Relatorio_Completo_Escolas_Diretorias.xlsx"

        # Configura√ß√µes de valida√ß√£o
        self.total_escolas_esperado = 63
        self.total_veiculos_esperado = 172
        self.distancia_kopenoti_esperada = 27.16

    def validar_integridade_completa(self):
        """Executa valida√ß√£o completa de todos os reposit√≥rios"""
        print("üîç VALIDA√á√ÉO COMPLETA DOS REPOSIT√ìRIOS")
        print("=" * 70)
        print(f"üìÖ {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}")
        print()

        resultados = {
            "arquivo_principal": self._validar_arquivo_principal(),
            "arquivo_veiculos": self._validar_arquivo_veiculos(),
            "dashboard": self._validar_dashboard(),
            "sincronizacao": self._validar_sincronizacao(),
        }

        self._gerar_relatorio_validacao(resultados)
        return all(resultados.values())

    def _validar_arquivo_principal(self):
        """Valida o arquivo Excel principal"""
        print("üìä VALIDANDO ARQUIVO PRINCIPAL")
        print("-" * 50)

        if not os.path.exists(self.arquivo_principal):
            print(f"‚ùå Arquivo n√£o encontrado: {self.arquivo_principal}")
            return False

        try:
            df = pd.read_excel(self.arquivo_principal)

            # Validar n√∫mero total de escolas
            if len(df) != self.total_escolas_esperado:
                print(
                    f"‚ùå Total de escolas incorreto: {len(df)} (esperado: {self.total_escolas_esperado})"
                )
                return False

            print(f"‚úÖ Total de escolas: {len(df)}")

            # Validar KOPENOTI
            kopenoti = df[
                df["Nome_Escola"].str.contains("KOPENOTI", na=False, case=False)
            ]
            if kopenoti.empty:
                print("‚ùå KOPENOTI n√£o encontrado")
                return False

            distancia = kopenoti.iloc[0]["Distancia_KM"]
            if abs(distancia - self.distancia_kopenoti_esperada) > 0.1:
                print(
                    f"‚ùå Dist√¢ncia KOPENOTI incorreta: {distancia:.2f} (esperado: {self.distancia_kopenoti_esperada})"
                )
                return False

            print(f"‚úÖ KOPENOTI: {distancia:.2f} km")

            # Validar colunas obrigat√≥rias
            colunas_obrigatorias = [
                "Nome_Escola",
                "Tipo_Escola",
                "Cidade_Escola",
                "Latitude_Escola",
                "Longitude_Escola",
                "Nome_Diretoria",
                "Distancia_KM",
            ]

            for col in colunas_obrigatorias:
                if col not in df.columns:
                    print(f"‚ùå Coluna obrigat√≥ria ausente: {col}")
                    return False

                nans = df[col].isna().sum()
                if nans > 0:
                    print(f"‚ö†Ô∏è  {nans} valores NaN em {col}")

            # Validar tipos de escola
            tipos = df["Tipo_Escola"].value_counts()
            print(f"üìã Tipos de escola:")
            for tipo, count in tipos.items():
                print(f"   {tipo}: {count}")

            # Validar diretorias
            diretorias = df["Nome_Diretoria"].nunique()
            print(f"üè¢ Diretorias √∫nicas: {diretorias}")

            print("‚úÖ Arquivo principal validado com sucesso")
            return True

        except Exception as e:
            print(f"‚ùå Erro ao validar arquivo principal: {e}")
            return False

    def _validar_arquivo_veiculos(self):
        """Valida o arquivo JSON de ve√≠culos"""
        print(f"\nüöó VALIDANDO ARQUIVO DE VE√çCULOS")
        print("-" * 50)

        if not os.path.exists(self.arquivo_veiculos):
            print(f"‚ùå Arquivo n√£o encontrado: {self.arquivo_veiculos}")
            return False

        try:
            with open(self.arquivo_veiculos, "r", encoding="utf-8") as f:
                data = json.load(f)

            # Validar estrutura
            if "metadata" not in data:
                print("‚ùå Metadata n√£o encontrada")
                return False

            metadata = data["metadata"]
            total_veiculos = metadata.get("total_veiculos", 0)

            if total_veiculos != self.total_veiculos_esperado:
                print(
                    f"‚ùå Total de ve√≠culos incorreto: {total_veiculos} (esperado: {self.total_veiculos_esperado})"
                )
                return False

            print(f"‚úÖ Total de ve√≠culos: {total_veiculos}")

            # Validar diretorias
            if "diretorias" in data:
                diretorias_com_veiculos = len(data["diretorias"])
                print(f"üè¢ Diretorias com dados de ve√≠culos: {diretorias_com_veiculos}")

            print("‚úÖ Arquivo de ve√≠culos validado com sucesso")
            return True

        except Exception as e:
            print(f"‚ùå Erro ao validar arquivo de ve√≠culos: {e}")
            return False

    def _validar_dashboard(self):
        """Valida o dashboard HTML"""
        print(f"\nüåê VALIDANDO DASHBOARD")
        print("-" * 50)

        if not os.path.exists(self.arquivo_dashboard):
            print(f"‚ùå Arquivo n√£o encontrado: {self.arquivo_dashboard}")
            return False

        try:
            with open(self.arquivo_dashboard, "r", encoding="utf-8") as f:
                content = f.read()

            # Contar escolas no dashboard
            match = re.search(r"const schoolsData = \[(.*?)\];", content, re.DOTALL)
            if not match:
                print("‚ùå schoolsData n√£o encontrado no dashboard")
                return False

            schools_text = match.group(1)
            school_count = schools_text.count("{")

            if school_count != self.total_escolas_esperado:
                print(
                    f"‚ùå Escolas no dashboard: {school_count} (esperado: {self.total_escolas_esperado})"
                )
                return False

            print(f"‚úÖ Escolas no dashboard: {school_count}")

            # Verificar se KOPENOTI est√° presente
            if "KOPENOTI" not in content:
                print("‚ùå KOPENOTI n√£o encontrado no dashboard")
                return False

            print("‚úÖ KOPENOTI presente no dashboard")

            print("‚úÖ Dashboard validado com sucesso")
            return True

        except Exception as e:
            print(f"‚ùå Erro ao validar dashboard: {e}")
            return False

    def _validar_sincronizacao(self):
        """Valida sincroniza√ß√£o entre sistemas"""
        print(f"\nüîÑ VALIDANDO SINCRONIZA√á√ÉO")
        print("-" * 50)

        try:
            # Extrair nomes das escolas do Excel
            df = pd.read_excel(self.arquivo_principal)
            escolas_excel = set(df["Nome_Escola"].str.upper().str.strip())

            # Extrair nomes das escolas do dashboard
            with open(self.arquivo_dashboard, "r", encoding="utf-8") as f:
                content = f.read()

            match = re.search(r"const schoolsData = \[(.*?)\];", content, re.DOTALL)
            schools_text = match.group(1)

            # Extrair nomes usando regex
            name_matches = re.findall(r'"name":\s*"([^"]+)"', schools_text)
            escolas_dashboard = set(nome.upper().strip() for nome in name_matches)

            # Comparar
            diferenca_excel = escolas_excel - escolas_dashboard
            diferenca_dashboard = escolas_dashboard - escolas_excel

            if diferenca_excel:
                print(
                    f"‚ùå Escolas no Excel mas n√£o no dashboard ({len(diferenca_excel)}):"
                )
                for escola in sorted(list(diferenca_excel)[:5]):
                    print(f"   - {escola}")
                return False

            if diferenca_dashboard:
                print(
                    f"‚ùå Escolas no dashboard mas n√£o no Excel ({len(diferenca_dashboard)}):"
                )
                for escola in sorted(list(diferenca_dashboard)[:5]):
                    print(f"   - {escola}")
                return False

            print("‚úÖ Dashboard e Excel perfeitamente sincronizados")
            print(f"‚úÖ {len(escolas_excel)} escolas id√™nticas em ambos os sistemas")

            return True

        except Exception as e:
            print(f"‚ùå Erro ao validar sincroniza√ß√£o: {e}")
            return False

    def _gerar_relatorio_validacao(self, resultados):
        """Gera relat√≥rio final de valida√ß√£o"""
        print(f"\nüéØ RELAT√ìRIO FINAL DE VALIDA√á√ÉO")
        print("=" * 70)

        total_testes = len(resultados)
        testes_aprovados = sum(resultados.values())

        print(f"üìä Testes executados: {total_testes}")
        print(f"‚úÖ Testes aprovados: {testes_aprovados}")
        print(f"‚ùå Testes falharam: {total_testes - testes_aprovados}")
        print(f"üìà Taxa de sucesso: {(testes_aprovados/total_testes)*100:.1f}%")

        print(f"\nüìã DETALHAMENTO:")
        for teste, resultado in resultados.items():
            status = "‚úÖ APROVADO" if resultado else "‚ùå FALHOU"
            print(f"   {teste.replace('_', ' ').title()}: {status}")

        if all(resultados.values()):
            print(f"\nüéâ TODOS OS REPOSIT√ìRIOS EST√ÉO √çNTEGROS E SINCRONIZADOS!")
            print(f"üöÄ Sistema pronto para uso em produ√ß√£o")
        else:
            print(f"\n‚ö†Ô∏è  A√á√ÉO NECESS√ÅRIA: Corrigir falhas antes de usar em produ√ß√£o")
            print(f"üí° Execute os scripts de corre√ß√£o apropriados")

    def criar_backup_repositorios(self):
        """Cria backup dos reposit√≥rios principais"""
        print(f"üíæ CRIANDO BACKUP DOS REPOSIT√ìRIOS")
        print("-" * 50)

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_dir = f"backup_{timestamp}"

        try:
            os.makedirs(backup_dir, exist_ok=True)

            arquivos_backup = [
                self.arquivo_principal,
                self.arquivo_veiculos,
                self.arquivo_dashboard,
            ]

            for arquivo in arquivos_backup:
                if os.path.exists(arquivo):
                    destino = os.path.join(backup_dir, arquivo)
                    shutil.copy2(arquivo, destino)
                    print(f"‚úÖ {arquivo} ‚Üí {destino}")
                else:
                    print(f"‚ö†Ô∏è  {arquivo} n√£o encontrado para backup")

            print(f"üíæ Backup criado em: {backup_dir}")
            return backup_dir

        except Exception as e:
            print(f"‚ùå Erro ao criar backup: {e}")
            return None

    def gerar_resumo_configuracao(self):
        """Gera resumo da configura√ß√£o atual"""
        print(f"\n‚öôÔ∏è  CONFIGURA√á√ÉO ATUAL DO SISTEMA")
        print("=" * 70)

        config = {
            "Arquivo Principal": self.arquivo_principal,
            "Arquivo Ve√≠culos": self.arquivo_veiculos,
            "Dashboard": self.arquivo_dashboard,
            "Total Escolas Esperado": self.total_escolas_esperado,
            "Total Ve√≠culos Esperado": self.total_veiculos_esperado,
            "Dist√¢ncia KOPENOTI": f"{self.distancia_kopenoti_esperada} km",
        }

        for chave, valor in config.items():
            print(f"üìã {chave}: {valor}")


def main():
    """Fun√ß√£o principal"""
    print("üèõÔ∏è  REPOSIT√ìRIO CENTRAL - VALIDADOR DE INTEGRIDADE")
    print("=" * 70)

    repo = RepositorioCentral()

    # Gerar resumo da configura√ß√£o
    repo.gerar_resumo_configuracao()

    # Criar backup antes da valida√ß√£o
    backup_dir = repo.criar_backup_repositorios()

    # Executar valida√ß√£o completa
    integridade_ok = repo.validar_integridade_completa()

    if integridade_ok:
        print(f"\nüéØ PR√ìXIMOS PASSOS RECOMENDADOS:")
        print(f"   1. ‚úÖ Reposit√≥rios validados e √≠ntegros")
        print(f"   2. üöÄ Sistema pronto para gera√ß√£o de relat√≥rios")
        print(f"   3. üìä Execute: python atualizar_relatorios_completos.py")
        print(f"   4. üíæ Backup dispon√≠vel em: {backup_dir}")
    else:
        print(f"\n‚ö†Ô∏è  A√á√ïES NECESS√ÅRIAS:")
        print(f"   1. üîß Corrigir falhas identificadas")
        print(f"   2. üîÑ Executar valida√ß√£o novamente")
        print(f"   3. üíæ Restaurar backup se necess√°rio: {backup_dir}")


if __name__ == "__main__":
    main()
